import { AbstractControl as NgAbstractControl, AbstractControlOptions as NgAbstractControlOptions, ValidationErrors as NgValidationErrors } from '@angular/forms';
import { Observable } from 'rxjs';
import { FormArray } from './formArray';
import { FormControl } from './formControl';
import { FormGroup } from './formGroup';
import { PersistManager } from './persistManager';
export declare type ValidationErrors<T = NgValidationErrors> = T;
export declare type ValidatorFn<T = any, E = any> = (control: AbstractControl<T>) => ValidationErrors<E> | null;
export declare type AsyncValidatorFn<T = any, E = any> = (control: AbstractControl<T>) => Promise<ValidationErrors<E> | null> | Observable<ValidationErrors<E> | null>;
export interface AbstractControlOptions<T = any, E = any> extends NgAbstractControlOptions {
    validators?: ValidatorFn<T, E> | ValidatorFn<T, E>[] | null;
    asyncValidators?: AsyncValidatorFn<T, E> | AsyncValidatorFn<T, E>[] | null;
}
export declare type ValidatorOrOpts = ValidatorFn | ValidatorFn[] | AbstractControlOptions | null;
export declare type AsyncValidator = AsyncValidatorFn | AsyncValidatorFn[] | null;
export declare type Validator = ValidatorFn | ValidatorFn[];
export interface ControlOptions {
    onlySelf?: boolean;
    emitEvent?: boolean;
    emitModelToViewChange?: boolean;
    emitViewToModelChange?: boolean;
}
export declare type ControlEventOptions = Pick<ControlOptions, 'emitEvent' | 'onlySelf'>;
export declare type OnlySelf = Pick<ControlOptions, 'onlySelf'>;
export declare type EmitEvent = Pick<ControlOptions, 'emitEvent'>;
export declare type ControlPath = Array<string | number> | string;
export declare type ControlState = 'VALID' | 'INVALID' | 'PENDING' | 'DISABLED';
export interface AbstractControl<T = any> extends NgAbstractControl {
    value: T;
}
export declare type ExtractStrings<T> = Extract<keyof T, string>;
export interface NgValidatorsErrors {
    required: true;
    email: true;
    pattern: {
        requiredPattern: string;
        actualValue: string;
    };
    minlength: {
        requiredLength: number;
        actualLength: number;
    };
    maxlength: {
        requiredLength: number;
        actualLength: number;
    };
    min: {
        min: number;
        actual: number;
    };
    max: {
        max: number;
        actual: number;
    };
}
export declare type BoxedValue<T> = {
    value: T;
    disabled?: boolean;
};
export declare type OrBoxedValue<T> = T | BoxedValue<T>;
export declare type Obj = {
    [key: string]: any;
};
declare type ArrayType<T> = T extends Array<infer R> ? R : any;
export declare type KeyValueControls<T extends Obj> = {
    [K in keyof T]: T[K] extends FormControl<T[K]> ? FormControl<T[K]> : T[K] extends FormGroup<T[K]> ? FormGroup<T[K]> : T[K] extends FormArray<ArrayType<T[K]>> ? FormArray<ArrayType<T[K]>> : AbstractControl<T[K]>;
};
export declare type ExtractAbstractControl<T, U> = T extends KeyValueControls<any> ? {
    [K in keyof U]: AbstractControl<U[K]>;
} : T;
export declare type ArrayKeys<T> = {
    [K in keyof T]: T[K] extends Array<any> ? K : never;
}[keyof T];
export declare type ControlFactory<T> = (value: T) => AbstractControl<T>;
export declare type ControlFactoryMap<T> = {
    [K in ArrayKeys<T>]?: ControlFactory<ArrayType<T[K]>>;
};
export interface PersistOptions<T> {
    debounceTime?: number;
    manager?: PersistManager<T>;
    arrControlFactory?: ControlFactoryMap<T>;
}
export {};
