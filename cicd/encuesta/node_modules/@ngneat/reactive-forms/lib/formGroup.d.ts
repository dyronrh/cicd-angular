import { FormGroup as NgFormGroup } from '@angular/forms';
import { Observable, Subscription } from 'rxjs';
import { AbstractControl, AsyncValidator, AsyncValidatorFn, ControlEventOptions, ControlOptions, ControlState, EmitEvent, ExtractAbstractControl, ExtractStrings, KeyValueControls, Obj, OnlySelf, PersistOptions, Validator, ValidatorFn, ValidatorOrOpts } from './types';
export declare class FormGroup<T extends Obj = any, E extends object = any> extends NgFormGroup {
    controls: ExtractAbstractControl<KeyValueControls<T>, T>;
    readonly value: T;
    readonly errors: E | null;
    readonly valueChanges: Observable<T>;
    readonly status: ControlState;
    readonly statusChanges: Observable<ControlState>;
    private touchChanges;
    private dirtyChanges;
    private errorsSubject;
    touch$: Observable<boolean>;
    dirty$: Observable<boolean>;
    readonly value$: Observable<T>;
    readonly disabled$: Observable<boolean>;
    readonly enabled$: Observable<boolean>;
    readonly status$: Observable<ControlState>;
    readonly errors$: Observable<E>;
    get asyncValidator(): AsyncValidatorFn<T> | null;
    set asyncValidator(asyncValidator: AsyncValidatorFn<T> | null);
    get validator(): ValidatorFn<T> | null;
    set validator(validator: ValidatorFn<T> | null);
    constructor(controls: ExtractAbstractControl<KeyValueControls<T>, T>, validatorOrOpts?: ValidatorOrOpts, asyncValidator?: AsyncValidator);
    select<R>(mapFn: (state: T) => R): Observable<R>;
    getRawValue(): T;
    get<K1 extends keyof T>(path?: [K1]): AbstractControl<T[K1]>;
    get<K1 extends keyof T, K2 extends keyof T[K1]>(path?: [K1, K2]): AbstractControl<T[K1][K2]>;
    get<K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(path?: [K1, K2, K3]): AbstractControl<T[K1][K2][K3]>;
    get(path?: string): AbstractControl;
    getControl<P1 extends keyof T>(prop1: P1): AbstractControl<T[P1]>;
    getControl<P1 extends keyof T, P2 extends keyof T[P1]>(prop1: P1, prop2: P2): AbstractControl<T[P1][P2]>;
    getControl<P1 extends keyof T, P2 extends keyof T[P1], P3 extends keyof T[P1][P2]>(prop1: P1, prop2: P2, prop3: P3): AbstractControl<T[P1][P2][P3]>;
    getControl<P1 extends keyof T, P2 extends keyof T[P1], P3 extends keyof T[P1][P2], P4 extends keyof T[P1][P2][P3]>(prop1: P1, prop2: P2, prop3: P3, prop4: P4): AbstractControl<T[P1][P2][P3][P4]>;
    addControl<K extends ExtractStrings<T>>(name: K, control: AbstractControl<T[K]>): void;
    removeControl(name: ExtractStrings<T>): void;
    contains(controlName: ExtractStrings<T>): boolean;
    setControl<K extends ExtractStrings<T>>(name: K, control: AbstractControl<T[K]>): void;
    setValue(valueOrObservable: Observable<T>, options?: ControlEventOptions): Subscription;
    setValue(valueOrObservable: T, options?: ControlEventOptions): void;
    patchValue(valueOrObservable: Observable<Partial<T>>, options?: ControlEventOptions): Subscription;
    patchValue(valueOrObservable: Partial<T>, options?: ControlEventOptions): void;
    disabledWhile(observable: Observable<boolean>, options?: ControlOptions): Subscription;
    enabledWhile(observable: Observable<boolean>, options?: ControlOptions): Subscription;
    mergeValidators(validators: Validator): void;
    mergeAsyncValidators(validators: AsyncValidator): void;
    markAsTouched(opts?: OnlySelf): void;
    markAsUntouched(opts?: OnlySelf): void;
    markAsPristine(opts?: OnlySelf): void;
    markAsDirty(opts?: OnlySelf): void;
    markAllAsDirty(): void;
    reset(formState?: Partial<T>, options?: ControlEventOptions): void;
    setValidators(newValidator: Validator): void;
    setAsyncValidators(newValidator: AsyncValidator): void;
    validateOn(observableValidation: Observable<null | object>): Subscription;
    hasError<K1 extends keyof T>(errorCode: ExtractStrings<E>, path?: [K1]): boolean;
    hasError<K1 extends keyof T, K2 extends keyof T[K1]>(errorCode: ExtractStrings<E>, path?: [K1, K2]): boolean;
    hasError<K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(errorCode: ExtractStrings<E>, path?: [K1, K2, K3]): boolean;
    hasError(errorCode: ExtractStrings<E>, path?: string): boolean;
    setErrors(errors: Partial<E> | null, opts?: EmitEvent): void;
    mergeErrors(errors: Partial<E>, opts?: EmitEvent): void;
    removeError(key: keyof E, opts?: EmitEvent): void;
    getError<K extends keyof E, K1 extends keyof T>(errorCode: K, path?: [K1]): E[K] | null;
    getError<K extends keyof E, K1 extends keyof T, K2 extends keyof T[K1]>(errorCode: K, path?: [K1, K2]): E[K] | null;
    getError<K extends keyof E, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(errorCode: K, path?: [K1, K2, K3]): E[K] | null;
    getError<K extends keyof E>(errorCode: K, path?: string): E[K] | null;
    hasErrorAndTouched<P1 extends keyof T>(error: ExtractStrings<E>, prop1?: P1): boolean;
    hasErrorAndTouched<P1 extends keyof T, P2 extends keyof T[P1]>(error: ExtractStrings<E>, prop1?: P1, prop2?: P2): boolean;
    hasErrorAndTouched<P1 extends keyof T, P2 extends keyof T[P1], P3 extends keyof T[P1][P2]>(error: ExtractStrings<E>, prop1?: P1, prop2?: P2, prop3?: P3): boolean;
    hasErrorAndTouched<P1 extends keyof T, P2 extends keyof T[P1], P3 extends keyof T[P1][P2], P4 extends keyof T[P1][P2][P3]>(error: ExtractStrings<E>, prop1?: P1, prop2?: P2, prop3?: P3, prop4?: P4): boolean;
    hasErrorAndDirty<P1 extends keyof T>(error: ExtractStrings<E>, prop1?: P1): boolean;
    hasErrorAndDirty<P1 extends keyof T, P2 extends keyof T[P1]>(error: ExtractStrings<E>, prop1?: P1, prop2?: P2): boolean;
    hasErrorAndDirty<P1 extends keyof T, P2 extends keyof T[P1], P3 extends keyof T[P1][P2]>(error: ExtractStrings<E>, prop1?: P1, prop2?: P2, prop3?: P3): boolean;
    hasErrorAndDirty<P1 extends keyof T, P2 extends keyof T[P1], P3 extends keyof T[P1][P2], P4 extends keyof T[P1][P2][P3]>(error: ExtractStrings<E>, prop1?: P1, prop2?: P2, prop3?: P3, prop4?: P4): boolean;
    setEnable(enable?: boolean, opts?: ControlEventOptions): void;
    setDisable(disable?: boolean, opts?: ControlEventOptions): void;
    persist(key: string, { debounceTime, manager, arrControlFactory }: PersistOptions<T>): Observable<T>;
    private restore;
}
