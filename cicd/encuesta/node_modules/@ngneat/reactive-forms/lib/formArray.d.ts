import { FormArray as NgFormArray } from '@angular/forms';
import { Observable, Subscription } from 'rxjs';
import { AbstractControl, AsyncValidator, AsyncValidatorFn, ControlEventOptions, ControlOptions, ControlPath, ControlState, EmitEvent, ExtractStrings, OnlySelf, Validator, ValidatorFn, ValidatorOrOpts } from './types';
export declare class FormArray<T = any, E extends object = any> extends NgFormArray {
    controls: Array<AbstractControl<T>>;
    readonly value: T[];
    readonly valueChanges: Observable<T[]>;
    readonly status: ControlState;
    readonly statusChanges: Observable<ControlState>;
    readonly errors: E | null;
    private touchChanges;
    private dirtyChanges;
    private errorsSubject;
    readonly touch$: Observable<boolean>;
    readonly dirty$: Observable<boolean>;
    readonly value$: Observable<T[]>;
    readonly disabled$: Observable<boolean>;
    readonly enabled$: Observable<boolean>;
    readonly status$: Observable<ControlState>;
    readonly errors$: Observable<E>;
    get asyncValidator(): AsyncValidatorFn<T[]> | null;
    set asyncValidator(asyncValidator: AsyncValidatorFn<T[]> | null);
    get validator(): ValidatorFn<T[]> | null;
    set validator(validator: ValidatorFn<T[]> | null);
    constructor(controls: Array<AbstractControl<T>>, validatorOrOpts?: ValidatorOrOpts, asyncValidator?: AsyncValidator);
    select<R>(mapFn: (state: T[]) => R): Observable<R>;
    getRawValue(): T[];
    at(index: number): AbstractControl<T>;
    setValue(valueOrObservable: Observable<T[]>, options?: ControlEventOptions): Subscription;
    setValue(valueOrObservable: T[], options?: ControlEventOptions): void;
    patchValue(valueOrObservable: Observable<T[]>, options?: ControlEventOptions): Subscription;
    patchValue(valueOrObservable: T[], options?: ControlEventOptions): void;
    push(control: AbstractControl<T>): void;
    insert(index: number, control: AbstractControl<T>): void;
    setControl(index: number, control: AbstractControl<T>): void;
    disabledWhile(observable: Observable<boolean>, options?: ControlOptions): Subscription;
    enabledWhile(observable: Observable<boolean>, options?: ControlOptions): Subscription;
    mergeValidators(validators: Validator): void;
    mergeAsyncValidators(validators: AsyncValidator): void;
    markAsTouched(opts?: OnlySelf): void;
    markAsUntouched(opts?: OnlySelf): void;
    markAsPristine(opts?: OnlySelf): void;
    markAsDirty(opts?: OnlySelf): void;
    markAllAsDirty(): void;
    reset(value?: T[], options?: ControlEventOptions): void;
    setValidators(newValidator: Validator): void;
    setAsyncValidators(newValidator: AsyncValidator): void;
    validateOn(observableValidation: Observable<null | object>): Subscription;
    hasError(errorCode: ExtractStrings<E>, path?: ControlPath): boolean;
    setErrors(errors: Partial<E> | null, opts?: EmitEvent): void;
    mergeErrors(errors: Partial<E>, opts?: EmitEvent): void;
    removeError(key: keyof E, opts?: EmitEvent): void;
    getError<K extends ExtractStrings<E>>(errorCode: K, path?: ControlPath): E[K];
    hasErrorAndTouched(errorCode: ExtractStrings<E>, path?: ControlPath): boolean;
    hasErrorAndDirty(errorCode: ExtractStrings<E>, path?: ControlPath): boolean;
    setEnable(enable?: boolean, opts?: ControlEventOptions): void;
    setDisable(disable?: boolean, opts?: ControlEventOptions): void;
    remove(value: T): void;
    removeWhen(predicate: (element: AbstractControl<T>) => boolean): void;
}
