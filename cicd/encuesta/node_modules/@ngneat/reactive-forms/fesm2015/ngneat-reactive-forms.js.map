{"version":3,"file":"ngneat-reactive-forms.js","sources":["../../../../projects/ngneat/reactive-forms/src/lib/utils.ts","../../../../projects/ngneat/reactive-forms/src/lib/control-actions.ts","../../../../projects/ngneat/reactive-forms/src/lib/formArray.ts","../../../../projects/ngneat/reactive-forms/src/lib/formControl.ts","../../../../projects/ngneat/reactive-forms/src/lib/localStorageManager.ts","../../../../projects/ngneat/reactive-forms/src/lib/formGroup.ts","../../../../projects/ngneat/reactive-forms/src/lib/formBuilder.ts","../../../../projects/ngneat/reactive-forms/src/lib/controlValueAccessor.ts","../../../../projects/ngneat/reactive-forms/src/lib/sessionStorageManager.ts","../../../../projects/ngneat/reactive-forms/src/ngneat-reactive-forms.ts"],"sourcesContent":["import { from, isObservable, Observable, of } from 'rxjs';\n\nexport function coerceArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\nexport function isFunction(x: any): x is Function {\n  return typeof x === 'function';\n}\n\nexport function isNil(v: any): boolean {\n  return v === null || v === undefined;\n}\n\nexport function isPromise(value: any): value is Promise<unknown> {\n  return typeof value?.then === 'function';\n}\n\nexport function wrapIntoObservable<T>(value: T | Promise<T> | Observable<T>): Observable<T> {\n  if (isObservable(value) || isPromise(value)) {\n    return from(value);\n  }\n\n  return of(value);\n}\n\nexport function mergeErrors<E>(existing: Partial<E>, toAdd: Partial<E>) {\n  if (!existing && !toAdd) {\n    return null;\n  }\n  return {\n    ...existing,\n    ...toAdd\n  };\n}\n\nexport function removeError<E>(errors: E, key: keyof E) {\n  if (!errors) {\n    return null;\n  }\n  const updatedErrors = {\n    ...errors\n  };\n  delete updatedErrors[key];\n  return Object.keys(updatedErrors).length > 0 ? updatedErrors : null;\n}\n","import { ValidationErrors, FormArray as NgFormArray } from '@angular/forms';\nimport { defer, merge, Observable, of, Subscription } from 'rxjs';\nimport { distinctUntilChanged, map, tap, debounceTime, switchMap } from 'rxjs/operators';\nimport { FormArray } from './formArray';\nimport { FormControl } from './formControl';\nimport { FormGroup } from './formGroup';\nimport {\n  AbstractControl,\n  ControlOptions,\n  ControlState,\n  ValidatorFn,\n  ControlPath,\n  PersistOptions,\n  ControlFactoryMap\n} from './types';\nimport { coerceArray, isNil, wrapIntoObservable } from './utils';\n\nfunction getControlValue<T>(control: AbstractControl<T>): T {\n  if ((control as any).getRawValue) {\n    return (control as any).getRawValue();\n  }\n  return control.value;\n}\n\nfunction compareErrors(a: ValidationErrors | null, b: ValidationErrors | null) {\n  if (isNil(a) || isNil(b)) {\n    return a === b;\n  }\n  return JSON.stringify(a) === JSON.stringify(b);\n}\n\nexport function controlValueChanges$<T>(control: AbstractControl<T>): Observable<T> {\n  return merge(\n    defer(() => of(getControlValue(control))),\n    control.valueChanges.pipe(map(() => getControlValue(control)))\n  );\n}\n\nexport function controlDisabled$<T>(control: AbstractControl<T>): Observable<boolean> {\n  return merge(\n    defer(() => of(control.disabled)),\n    control.statusChanges.pipe(\n      map(() => control.disabled),\n      distinctUntilChanged()\n    )\n  );\n}\n\nexport function controlEnabled$<T>(control: AbstractControl<T>): Observable<boolean> {\n  return merge(\n    defer(() => of(control.enabled)),\n    control.statusChanges.pipe(\n      map(() => control.enabled),\n      distinctUntilChanged()\n    )\n  );\n}\n\nexport function controlStatusChanges$<T>(control: AbstractControl<T>): Observable<ControlState> {\n  return merge(\n    defer(() => of(control.status as ControlState)),\n    control.statusChanges.pipe(\n      map(() => control.status as ControlState),\n      distinctUntilChanged()\n    )\n  );\n}\n\nexport function controlErrorChanges$<E>(\n  control: AbstractControl,\n  errors$: Observable<Partial<E>>\n): Observable<E | null> {\n  return merge(\n    defer(() => of(control.errors as E)),\n    errors$ as Observable<E>,\n    control.valueChanges.pipe(\n      map(() => control.errors as E),\n      distinctUntilChanged((a, b) => compareErrors(a, b))\n    )\n  );\n}\n\nexport function enableControl<T>(control: AbstractControl<T>, enabled: boolean, opts?: ControlOptions): void {\n  if (enabled) {\n    control.enable(opts);\n  } else {\n    control.disable(opts);\n  }\n}\n\nexport function disableControl<T>(control: AbstractControl<T>, disabled: boolean, opts?: ControlOptions): void {\n  enableControl(control, !disabled, opts);\n}\n\nexport function controlDisabledWhile<T>(\n  control: AbstractControl<T>,\n  observable: Observable<boolean>,\n  opts?: ControlOptions\n): Subscription {\n  return observable.subscribe(isDisabled => disableControl(control, isDisabled, opts));\n}\n\nexport function controlEnabledWhile<T>(\n  control: AbstractControl<T>,\n  observable: Observable<boolean>,\n  opts?: ControlOptions\n): Subscription {\n  return observable.subscribe(isEnabled => enableControl(control, isEnabled, opts));\n}\n\nexport function mergeControlValidators<T, Control extends AbstractControl<T>>(\n  control: Control,\n  validators: ValidatorFn<T> | ValidatorFn<T>[]\n): void {\n  control.setValidators([control.validator, ...coerceArray(validators)]);\n  control.updateValueAndValidity();\n}\n\nexport function validateControlOn<T>(control: AbstractControl<T>, validation: Observable<null | object>): Subscription {\n  return validation.subscribe(maybeError => {\n    control.setErrors(maybeError);\n  });\n}\n\nexport function hasErrorAndTouched<T>(control: AbstractControl<T>, error: string, path?: ControlPath): boolean {\n  const hasError = control.hasError(error, !path || path.length === 0 ? undefined : path);\n  return hasError && control.touched;\n}\n\nexport function hasErrorAndDirty<T>(control: AbstractControl<T>, error: string, path?: ControlPath): boolean {\n  const hasError = control.hasError(error, !path || path.length === 0 ? undefined : path);\n  return hasError && control.dirty;\n}\n\nexport function markAllDirty<T>(control: FormArray<T> | FormGroup<T>): void {\n  control.markAsDirty({ onlySelf: true });\n  (control as any)._forEachChild(control => control.markAllAsDirty());\n}\n\nexport function selectControlValue$<T, R>(\n  control: FormGroup<T> | FormArray<T> | FormControl<T>,\n  mapFn: (state: T | T[]) => R\n): Observable<R> {\n  return (control.value$ as Observable<any>).pipe(map(mapFn), distinctUntilChanged());\n}\n\nexport function persistValue$<T>(control: FormGroup<T>, key: string, options: PersistOptions<T>): Observable<T> {\n  return control.valueChanges.pipe(\n    debounceTime(options.debounceTime),\n    switchMap(value => wrapIntoObservable(options.manager.setValue(key, value)))\n  );\n}\n\nexport function handleFormArrays<T>(\n  control: AbstractControl<T>,\n  formValue: T,\n  arrControlFactory: ControlFactoryMap<T>\n) {\n  Object.keys(formValue).forEach(controlName => {\n    const value = formValue[controlName];\n    if (Array.isArray(value) && control.get(controlName) instanceof NgFormArray) {\n      if (!arrControlFactory || (arrControlFactory && !(controlName in arrControlFactory))) {\n        throw new Error(`Please provide arrControlFactory for ${controlName}`);\n      }\n      const current = control.get(controlName) as NgFormArray;\n      const fc = arrControlFactory[controlName];\n      clearFormArray(current);\n      value.forEach((v, i) => current.insert(i, fc(v)));\n    }\n  });\n}\n\nexport function clearFormArray(control: NgFormArray) {\n  while (control.length !== 0) {\n    control.removeAt(0);\n  }\n}\n","import { FormArray as NgFormArray } from '@angular/forms';\nimport { isObservable, Observable, Subject, Subscription } from 'rxjs';\nimport { distinctUntilChanged, map } from 'rxjs/operators';\nimport {\n  controlDisabled$,\n  controlDisabledWhile,\n  controlEnabled$,\n  controlEnabledWhile,\n  controlErrorChanges$,\n  controlStatusChanges$,\n  controlValueChanges$,\n  disableControl,\n  enableControl,\n  hasErrorAndDirty,\n  hasErrorAndTouched,\n  markAllDirty,\n  mergeControlValidators\n} from './control-actions';\nimport {\n  AbstractControl,\n  AsyncValidator,\n  AsyncValidatorFn,\n  ControlEventOptions,\n  ControlOptions,\n  ControlPath,\n  ControlState,\n  EmitEvent,\n  ExtractStrings,\n  OnlySelf,\n  Validator,\n  ValidatorFn,\n  ValidatorOrOpts\n} from './types';\nimport { coerceArray, mergeErrors, removeError } from './utils';\n\nexport class FormArray<T = any, E extends object = any> extends NgFormArray {\n  readonly value: T[];\n  readonly valueChanges: Observable<T[]>;\n  readonly status: ControlState;\n  readonly statusChanges: Observable<ControlState>;\n  readonly errors: E | null;\n\n  private touchChanges = new Subject<boolean>();\n  private dirtyChanges = new Subject<boolean>();\n  private errorsSubject = new Subject<Partial<E>>();\n\n  readonly touch$ = this.touchChanges.asObservable().pipe(distinctUntilChanged());\n  readonly dirty$ = this.dirtyChanges.asObservable().pipe(distinctUntilChanged());\n\n  readonly value$ = controlValueChanges$<T[]>(this);\n  readonly disabled$ = controlDisabled$(this);\n  readonly enabled$ = controlEnabled$(this);\n  readonly status$ = controlStatusChanges$(this);\n  readonly errors$ = controlErrorChanges$<E>(this, this.errorsSubject.asObservable());\n\n  get asyncValidator(): AsyncValidatorFn<T[]> | null {\n    return super.asyncValidator;\n  }\n  set asyncValidator(asyncValidator: AsyncValidatorFn<T[]> | null) {\n    super.asyncValidator = asyncValidator;\n  }\n\n  get validator(): ValidatorFn<T[]> | null {\n    return super.validator;\n  }\n  set validator(validator: ValidatorFn<T[]> | null) {\n    super.validator = validator;\n  }\n\n  constructor(\n    public controls: Array<AbstractControl<T>>,\n    validatorOrOpts?: ValidatorOrOpts,\n    asyncValidator?: AsyncValidator\n  ) {\n    super(controls, validatorOrOpts, asyncValidator);\n  }\n\n  select<R>(mapFn: (state: T[]) => R): Observable<R> {\n    return this.value$.pipe(map(mapFn), distinctUntilChanged());\n  }\n\n  getRawValue(): T[] {\n    return super.getRawValue();\n  }\n\n  at(index: number): AbstractControl<T> {\n    return super.at(index) as AbstractControl<T>;\n  }\n\n  setValue(valueOrObservable: Observable<T[]>, options?: ControlEventOptions): Subscription;\n  setValue(valueOrObservable: T[], options?: ControlEventOptions): void;\n  setValue(valueOrObservable: T[] | Observable<T[]>, options?: ControlEventOptions): Subscription | void {\n    if (isObservable(valueOrObservable)) {\n      return valueOrObservable.subscribe(value => super.setValue(value, options));\n    }\n\n    super.setValue(valueOrObservable, options);\n  }\n\n  patchValue(valueOrObservable: Observable<T[]>, options?: ControlEventOptions): Subscription;\n  patchValue(valueOrObservable: T[], options?: ControlEventOptions): void;\n  patchValue(valueOrObservable: any, options?: ControlEventOptions): Subscription | void {\n    if (isObservable(valueOrObservable)) {\n      return valueOrObservable.subscribe((value: T[]) => super.patchValue(value, options));\n    }\n\n    super.patchValue(valueOrObservable as T[], options);\n  }\n\n  push(control: AbstractControl<T>): void {\n    return super.push(control);\n  }\n\n  insert(index: number, control: AbstractControl<T>): void {\n    return super.insert(index, control);\n  }\n\n  setControl(index: number, control: AbstractControl<T>): void {\n    return super.setControl(index, control);\n  }\n\n  disabledWhile(observable: Observable<boolean>, options?: ControlOptions) {\n    return controlDisabledWhile(this, observable, options);\n  }\n\n  enabledWhile(observable: Observable<boolean>, options?: ControlOptions) {\n    return controlEnabledWhile(this, observable, options);\n  }\n\n  mergeValidators(validators: Validator) {\n    mergeControlValidators(this, validators);\n  }\n\n  mergeAsyncValidators(validators: AsyncValidator) {\n    this.setAsyncValidators([this.asyncValidator, ...coerceArray(validators)]);\n    this.updateValueAndValidity();\n  }\n\n  markAsTouched(opts?: OnlySelf): void {\n    super.markAsTouched(opts);\n    this.touchChanges.next(true);\n  }\n\n  markAsUntouched(opts?: OnlySelf): void {\n    super.markAsUntouched(opts);\n    this.touchChanges.next(false);\n  }\n\n  markAsPristine(opts?: OnlySelf): void {\n    super.markAsPristine(opts);\n    this.dirtyChanges.next(false);\n  }\n\n  markAsDirty(opts?: OnlySelf): void {\n    super.markAsDirty(opts);\n    this.dirtyChanges.next(true);\n  }\n\n  markAllAsDirty(): void {\n    markAllDirty(this);\n  }\n\n  reset(value?: T[], options?: ControlEventOptions): void {\n    super.reset(value, options);\n  }\n\n  setValidators(newValidator: Validator): void {\n    super.setValidators(newValidator);\n    super.updateValueAndValidity();\n  }\n\n  setAsyncValidators(newValidator: AsyncValidator): void {\n    super.setAsyncValidators(newValidator);\n    super.updateValueAndValidity();\n  }\n\n  validateOn(observableValidation: Observable<null | object>) {\n    return observableValidation.subscribe(maybeError => {\n      this.setErrors(maybeError);\n    });\n  }\n\n  hasError(errorCode: ExtractStrings<E>, path?: ControlPath) {\n    return super.hasError(errorCode, path);\n  }\n\n  setErrors(errors: Partial<E> | null, opts: EmitEvent = {}) {\n    this.errorsSubject.next(errors);\n    return super.setErrors(errors, opts);\n  }\n\n  mergeErrors(errors: Partial<E>, opts: EmitEvent = {}): void {\n    this.setErrors(mergeErrors<E>(this.errors, errors), opts);\n  }\n\n  removeError(key: keyof E, opts: EmitEvent = {}): void {\n    this.setErrors(removeError<E>(this.errors, key), opts);\n  }\n\n  getError<K extends ExtractStrings<E>>(errorCode: K, path?: ControlPath) {\n    return super.getError(errorCode, path) as E[K] | null;\n  }\n\n  hasErrorAndTouched(errorCode: ExtractStrings<E>, path?: ControlPath): boolean {\n    return hasErrorAndTouched(this, errorCode, path);\n  }\n\n  hasErrorAndDirty(errorCode: ExtractStrings<E>, path?: ControlPath): boolean {\n    return hasErrorAndDirty(this, errorCode, path);\n  }\n\n  setEnable(enable = true, opts?: ControlEventOptions) {\n    enableControl(this, enable, opts);\n  }\n\n  setDisable(disable = true, opts?: ControlEventOptions) {\n    disableControl(this, disable, opts);\n  }\n\n  remove(value: T): void {\n    this.removeWhen(v => v.value === value);\n  }\n\n  removeWhen(predicate: (element: AbstractControl<T>) => boolean): void {\n    const toRemove: number[] = [];\n    for (let i = this.length - 1; i >= 0; --i) {\n      if (predicate(this.at(i))) {\n        this.removeAt(i);\n      }\n    }\n  }\n}\n","import { FormControl as NgFormControl } from '@angular/forms';\nimport { isObservable, Observable, Subject, Subscription } from 'rxjs';\nimport { distinctUntilChanged } from 'rxjs/operators';\nimport {\n  controlDisabled$,\n  controlDisabledWhile,\n  controlEnabled$,\n  controlEnabledWhile,\n  controlErrorChanges$,\n  controlStatusChanges$,\n  controlValueChanges$,\n  disableControl,\n  enableControl,\n  hasErrorAndDirty,\n  hasErrorAndTouched,\n  mergeControlValidators,\n  validateControlOn\n} from './control-actions';\nimport {\n  AsyncValidator,\n  AsyncValidatorFn,\n  ControlEventOptions,\n  ControlOptions,\n  ControlState,\n  EmitEvent,\n  ExtractStrings,\n  OnlySelf,\n  OrBoxedValue,\n  Validator,\n  ValidatorFn,\n  ValidatorOrOpts\n} from './types';\nimport { coerceArray, mergeErrors, removeError } from './utils';\n\nexport class FormControl<T = any, E extends object = any> extends NgFormControl {\n  readonly value: T;\n  readonly errors: E | null;\n  readonly valueChanges: Observable<T>;\n  readonly status: ControlState;\n  readonly statusChanges: Observable<ControlState>;\n\n  private touchChanges = new Subject<boolean>();\n  private dirtyChanges = new Subject<boolean>();\n  private errorsSubject = new Subject<Partial<E>>();\n\n  readonly touch$ = this.touchChanges.asObservable().pipe(distinctUntilChanged());\n  readonly dirty$ = this.dirtyChanges.asObservable().pipe(distinctUntilChanged());\n\n  readonly value$ = controlValueChanges$<T>(this);\n  readonly disabled$ = controlDisabled$<T>(this);\n  readonly enabled$ = controlEnabled$<T>(this);\n  readonly status$ = controlStatusChanges$<T>(this);\n  readonly errors$ = controlErrorChanges$<E>(this, this.errorsSubject.asObservable());\n\n  get asyncValidator(): AsyncValidatorFn<T> | null {\n    return super.asyncValidator;\n  }\n  set asyncValidator(asyncValidator: AsyncValidatorFn<T> | null) {\n    super.asyncValidator = asyncValidator;\n  }\n\n  get validator(): ValidatorFn<T> | null {\n    return super.validator;\n  }\n  set validator(validator: ValidatorFn<T> | null) {\n    super.validator = validator;\n  }\n\n  constructor(formState?: OrBoxedValue<T>, validatorOrOpts?: ValidatorOrOpts, asyncValidator?: AsyncValidator) {\n    super(formState, validatorOrOpts, asyncValidator);\n  }\n\n  setValue(valueOrObservable: Observable<T>, options?: ControlOptions): Subscription;\n  setValue(valueOrObservable: T, options?: ControlOptions): void;\n  setValue(valueOrObservable: any, options?: ControlOptions): Subscription | void {\n    if (isObservable(valueOrObservable)) {\n      return valueOrObservable.subscribe(value => super.setValue(value, options));\n    }\n\n    super.setValue(valueOrObservable, options);\n  }\n\n  patchValue(valueOrObservable: Observable<T>, options?: ControlOptions): Subscription;\n  patchValue(valueOrObservable: T, options?: ControlOptions): void;\n  patchValue(valueOrObservable: any, options?: ControlOptions): Subscription | void {\n    if (isObservable(valueOrObservable)) {\n      return valueOrObservable.subscribe(value => super.patchValue(value, options));\n    }\n\n    super.patchValue(valueOrObservable, options);\n  }\n\n  disabledWhile(observable: Observable<boolean>, options?: ControlOptions) {\n    return controlDisabledWhile(this, observable, options);\n  }\n\n  enabledWhile(observable: Observable<boolean>, options?: ControlOptions) {\n    return controlEnabledWhile(this, observable, options);\n  }\n\n  mergeValidators(validators: Validator) {\n    mergeControlValidators(this, validators);\n  }\n\n  mergeAsyncValidators(validators: AsyncValidator) {\n    this.setAsyncValidators([this.asyncValidator, ...coerceArray(validators)]);\n    this.updateValueAndValidity();\n  }\n\n  markAsTouched(opts?: OnlySelf): void {\n    super.markAsTouched(opts);\n    this.touchChanges.next(true);\n  }\n\n  markAsUntouched(opts?: OnlySelf): void {\n    super.markAsUntouched(opts);\n    this.touchChanges.next(false);\n  }\n\n  markAsPristine(opts?: OnlySelf): void {\n    super.markAsPristine(opts);\n    this.dirtyChanges.next(false);\n  }\n\n  markAsDirty(opts?: OnlySelf): void {\n    super.markAsDirty(opts);\n    this.dirtyChanges.next(true);\n  }\n\n  markAllAsDirty(): void {\n    this.markAsDirty({ onlySelf: true });\n  }\n\n  reset(formState?: OrBoxedValue<T>, options?: ControlEventOptions): void {\n    super.reset(formState, options);\n  }\n\n  setValidators(newValidator: Validator): void {\n    super.setValidators(newValidator);\n    super.updateValueAndValidity();\n  }\n\n  setAsyncValidators(newValidator: AsyncValidator): void {\n    super.setAsyncValidators(newValidator);\n    super.updateValueAndValidity();\n  }\n\n  validateOn(observableValidation: Observable<null | object>) {\n    return validateControlOn(this, observableValidation);\n  }\n\n  getError<K extends ExtractStrings<E>>(errorCode: K): E[K] | null {\n    return super.getError(errorCode) as E[K] | null;\n  }\n\n  hasError<K extends ExtractStrings<E>>(errorCode: K) {\n    return super.hasError(errorCode);\n  }\n\n  setErrors(errors: Partial<E> | null, opts: EmitEvent = {}) {\n    this.errorsSubject.next(errors);\n    return super.setErrors(errors, opts);\n  }\n\n  mergeErrors(errors: Partial<E>, opts: EmitEvent = {}): void {\n    this.setErrors(mergeErrors<E>(this.errors, errors), opts);\n  }\n\n  removeError(key: keyof E, opts: EmitEvent = {}): void {\n    this.setErrors(removeError<E>(this.errors, key), opts);\n  }\n\n  hasErrorAndTouched(error: ExtractStrings<E>): boolean {\n    return hasErrorAndTouched(this, error);\n  }\n\n  hasErrorAndDirty(error: ExtractStrings<E>): boolean {\n    return hasErrorAndDirty(this, error);\n  }\n\n  setEnable(enable = true, opts?: ControlEventOptions) {\n    enableControl(this, enable, opts);\n  }\n\n  setDisable(disable = true, opts?: ControlEventOptions) {\n    disableControl(this, disable, opts);\n  }\n}\n","import { PersistManager } from './persistManager';\n\nexport class LocalStorageManager<T> implements PersistManager<T> {\n  setValue(key: string, data: T): T {\n    localStorage.setItem(key, JSON.stringify(data));\n    return data;\n  }\n\n  getValue(key: string): T {\n    return JSON.parse(localStorage.getItem(key) || '{}');\n  }\n}\n","import { FormGroup as NgFormGroup } from '@angular/forms';\nimport { isObservable, Observable, Subject, Subscription } from 'rxjs';\nimport { distinctUntilChanged, switchMap, take, tap } from 'rxjs/operators';\nimport {\n  controlDisabled$,\n  controlDisabledWhile,\n  controlEnabled$,\n  controlEnabledWhile,\n  controlErrorChanges$,\n  controlStatusChanges$,\n  controlValueChanges$,\n  disableControl,\n  enableControl,\n  handleFormArrays,\n  hasErrorAndDirty,\n  hasErrorAndTouched,\n  markAllDirty,\n  mergeControlValidators,\n  persistValue$,\n  selectControlValue$,\n  validateControlOn\n} from './control-actions';\nimport { LocalStorageManager } from './localStorageManager';\nimport { PersistManager } from './persistManager';\nimport {\n  AbstractControl,\n  AsyncValidator,\n  AsyncValidatorFn,\n  ControlEventOptions,\n  ControlFactoryMap,\n  ControlOptions,\n  ControlState,\n  EmitEvent,\n  ExtractAbstractControl,\n  ExtractStrings,\n  KeyValueControls,\n  Obj,\n  OnlySelf,\n  PersistOptions,\n  Validator,\n  ValidatorFn,\n  ValidatorOrOpts\n} from './types';\nimport { coerceArray, mergeErrors, removeError, wrapIntoObservable } from './utils';\n\nexport class FormGroup<T extends Obj = any, E extends object = any> extends NgFormGroup {\n  readonly value: T;\n  readonly errors: E | null;\n  readonly valueChanges: Observable<T>;\n  readonly status: ControlState;\n  readonly statusChanges: Observable<ControlState>;\n\n  private touchChanges = new Subject<boolean>();\n  private dirtyChanges = new Subject<boolean>();\n  private errorsSubject = new Subject<Partial<E>>();\n\n  touch$ = this.touchChanges.asObservable().pipe(distinctUntilChanged());\n  dirty$ = this.dirtyChanges.asObservable().pipe(distinctUntilChanged());\n\n  readonly value$ = controlValueChanges$<T>(this);\n  readonly disabled$ = controlDisabled$<T>(this);\n  readonly enabled$ = controlEnabled$<T>(this);\n  readonly status$ = controlStatusChanges$<T>(this);\n  readonly errors$ = controlErrorChanges$<E>(this, this.errorsSubject.asObservable());\n\n  get asyncValidator(): AsyncValidatorFn<T> | null {\n    return super.asyncValidator;\n  }\n  set asyncValidator(asyncValidator: AsyncValidatorFn<T> | null) {\n    super.asyncValidator = asyncValidator;\n  }\n\n  get validator(): ValidatorFn<T> | null {\n    return super.validator;\n  }\n  set validator(validator: ValidatorFn<T> | null) {\n    super.validator = validator;\n  }\n\n  constructor(\n    public controls: ExtractAbstractControl<KeyValueControls<T>, T>,\n    validatorOrOpts?: ValidatorOrOpts,\n    asyncValidator?: AsyncValidator\n  ) {\n    super(controls, validatorOrOpts, asyncValidator);\n  }\n\n  select<R>(mapFn: (state: T) => R): Observable<R> {\n    return selectControlValue$(this, mapFn);\n  }\n\n  getRawValue(): T {\n    return super.getRawValue();\n  }\n\n  get<K1 extends keyof T>(path?: [K1]): AbstractControl<T[K1]>;\n  get<K1 extends keyof T, K2 extends keyof T[K1]>(path?: [K1, K2]): AbstractControl<T[K1][K2]>;\n  get<K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(\n    path?: [K1, K2, K3]\n  ): AbstractControl<T[K1][K2][K3]>;\n  get(path?: string): AbstractControl;\n  get(path: any) {\n    return super.get(path);\n  }\n\n  getControl<P1 extends keyof T>(prop1: P1): AbstractControl<T[P1]>;\n  getControl<P1 extends keyof T, P2 extends keyof T[P1]>(prop1: P1, prop2: P2): AbstractControl<T[P1][P2]>;\n  getControl<P1 extends keyof T, P2 extends keyof T[P1], P3 extends keyof T[P1][P2]>(\n    prop1: P1,\n    prop2: P2,\n    prop3: P3\n  ): AbstractControl<T[P1][P2][P3]>;\n  getControl<P1 extends keyof T, P2 extends keyof T[P1], P3 extends keyof T[P1][P2], P4 extends keyof T[P1][P2][P3]>(\n    prop1: P1,\n    prop2: P2,\n    prop3: P3,\n    prop4: P4\n  ): AbstractControl<T[P1][P2][P3][P4]>;\n  getControl(...names: any): AbstractControl<any> {\n    return this.get(names.join('.'));\n  }\n\n  addControl<K extends ExtractStrings<T>>(name: K, control: AbstractControl<T[K]>): void {\n    super.addControl(name, control);\n  }\n\n  removeControl(name: ExtractStrings<T>): void {\n    super.removeControl(name);\n  }\n\n  contains(controlName: ExtractStrings<T>): boolean {\n    return super.contains(controlName);\n  }\n\n  setControl<K extends ExtractStrings<T>>(name: K, control: AbstractControl<T[K]>): void {\n    super.setControl(name, control);\n  }\n\n  setValue(valueOrObservable: Observable<T>, options?: ControlEventOptions): Subscription;\n  setValue(valueOrObservable: T, options?: ControlEventOptions): void;\n  setValue(valueOrObservable: any, options?: ControlEventOptions): any {\n    if (isObservable(valueOrObservable)) {\n      return valueOrObservable.subscribe(value => super.setValue(value, options));\n    }\n\n    super.setValue(valueOrObservable, options);\n  }\n\n  patchValue(valueOrObservable: Observable<Partial<T>>, options?: ControlEventOptions): Subscription;\n  patchValue(valueOrObservable: Partial<T>, options?: ControlEventOptions): void;\n  patchValue(valueOrObservable: any, options?: ControlEventOptions): Subscription | void {\n    if (isObservable(valueOrObservable)) {\n      return valueOrObservable.subscribe(value => super.patchValue(value, options));\n    }\n\n    super.patchValue(valueOrObservable, options);\n  }\n\n  disabledWhile(observable: Observable<boolean>, options?: ControlOptions) {\n    return controlDisabledWhile(this, observable, options);\n  }\n\n  enabledWhile(observable: Observable<boolean>, options?: ControlOptions) {\n    return controlEnabledWhile(this, observable, options);\n  }\n\n  mergeValidators(validators: Validator) {\n    mergeControlValidators(this, validators);\n  }\n\n  mergeAsyncValidators(validators: AsyncValidator) {\n    this.setAsyncValidators([this.asyncValidator, ...coerceArray(validators)]);\n    this.updateValueAndValidity();\n  }\n\n  markAsTouched(opts?: OnlySelf): void {\n    super.markAsTouched(opts);\n    this.touchChanges.next(true);\n  }\n\n  markAsUntouched(opts?: OnlySelf): void {\n    super.markAsUntouched(opts);\n    this.touchChanges.next(false);\n  }\n\n  markAsPristine(opts?: OnlySelf): void {\n    super.markAsPristine(opts);\n    this.dirtyChanges.next(false);\n  }\n\n  markAsDirty(opts?: OnlySelf): void {\n    super.markAsDirty(opts);\n    this.dirtyChanges.next(true);\n  }\n\n  markAllAsDirty(): void {\n    markAllDirty(this);\n  }\n\n  reset(formState?: Partial<T>, options?: ControlEventOptions): void {\n    super.reset(formState, options);\n  }\n\n  setValidators(newValidator: Validator): void {\n    super.setValidators(newValidator);\n    super.updateValueAndValidity();\n  }\n\n  setAsyncValidators(newValidator: AsyncValidator): void {\n    super.setAsyncValidators(newValidator);\n    super.updateValueAndValidity();\n  }\n\n  validateOn(observableValidation: Observable<null | object>) {\n    return validateControlOn(this, observableValidation);\n  }\n\n  hasError<K1 extends keyof T>(errorCode: ExtractStrings<E>, path?: [K1]): boolean;\n  hasError<K1 extends keyof T, K2 extends keyof T[K1]>(errorCode: ExtractStrings<E>, path?: [K1, K2]): boolean;\n  hasError<K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(\n    errorCode: ExtractStrings<E>,\n    path?: [K1, K2, K3]\n  ): boolean;\n  hasError(errorCode: ExtractStrings<E>, path?: string): boolean;\n  hasError(errorCode: ExtractStrings<E>, path?: any): boolean {\n    return super.hasError(errorCode, path);\n  }\n\n  setErrors(errors: Partial<E> | null, opts: EmitEvent = {}) {\n    this.errorsSubject.next(errors);\n    return super.setErrors(errors, opts);\n  }\n\n  mergeErrors(errors: Partial<E>, opts: EmitEvent = {}): void {\n    this.setErrors(mergeErrors<E>(this.errors, errors), opts);\n  }\n\n  removeError(key: keyof E, opts: EmitEvent = {}): void {\n    this.setErrors(removeError<E>(this.errors, key), opts);\n  }\n\n  getError<K extends keyof E, K1 extends keyof T>(errorCode: K, path?: [K1]): E[K] | null;\n  getError<K extends keyof E, K1 extends keyof T, K2 extends keyof T[K1]>(errorCode: K, path?: [K1, K2]): E[K] | null;\n  getError<K extends keyof E, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(\n    errorCode: K,\n    path?: [K1, K2, K3]\n  ): E[K] | null;\n  getError<K extends keyof E>(errorCode: K, path?: string): E[K] | null;\n  getError<K extends keyof E>(errorCode: K, path?: any): E[K] | null {\n    return super.getError(errorCode as any, path) as E[K] | null;\n  }\n\n  hasErrorAndTouched<P1 extends keyof T>(error: ExtractStrings<E>, prop1?: P1): boolean;\n  hasErrorAndTouched<P1 extends keyof T, P2 extends keyof T[P1]>(\n    error: ExtractStrings<E>,\n    prop1?: P1,\n    prop2?: P2\n  ): boolean;\n  hasErrorAndTouched<P1 extends keyof T, P2 extends keyof T[P1], P3 extends keyof T[P1][P2]>(\n    error: ExtractStrings<E>,\n    prop1?: P1,\n    prop2?: P2,\n    prop3?: P3\n  ): boolean;\n  hasErrorAndTouched<\n    P1 extends keyof T,\n    P2 extends keyof T[P1],\n    P3 extends keyof T[P1][P2],\n    P4 extends keyof T[P1][P2][P3]\n  >(error: ExtractStrings<E>, prop1?: P1, prop2?: P2, prop3?: P3, prop4?: P4): boolean;\n  hasErrorAndTouched(error: any, ...path: any): boolean {\n    return hasErrorAndTouched(this, error, ...path);\n  }\n\n  hasErrorAndDirty<P1 extends keyof T>(error: ExtractStrings<E>, prop1?: P1): boolean;\n  hasErrorAndDirty<P1 extends keyof T, P2 extends keyof T[P1]>(\n    error: ExtractStrings<E>,\n    prop1?: P1,\n    prop2?: P2\n  ): boolean;\n  hasErrorAndDirty<P1 extends keyof T, P2 extends keyof T[P1], P3 extends keyof T[P1][P2]>(\n    error: ExtractStrings<E>,\n    prop1?: P1,\n    prop2?: P2,\n    prop3?: P3\n  ): boolean;\n  hasErrorAndDirty<\n    P1 extends keyof T,\n    P2 extends keyof T[P1],\n    P3 extends keyof T[P1][P2],\n    P4 extends keyof T[P1][P2][P3]\n  >(error: ExtractStrings<E>, prop1?: P1, prop2?: P2, prop3?: P3, prop4?: P4): boolean;\n  hasErrorAndDirty(error: any, ...path: any): boolean {\n    return hasErrorAndDirty(this, error, ...path);\n  }\n\n  setEnable(enable = true, opts?: ControlEventOptions) {\n    enableControl(this, enable, opts);\n  }\n\n  setDisable(disable = true, opts?: ControlEventOptions) {\n    disableControl(this, disable, opts);\n  }\n\n  persist(key: string, { debounceTime, manager, arrControlFactory }: PersistOptions<T>): Observable<T> {\n    const persistManager = manager || new LocalStorageManager();\n    return this.restore(key, persistManager, arrControlFactory).pipe(\n      switchMap(() =>\n        persistValue$(this, key, {\n          debounceTime: debounceTime || 250,\n          manager: persistManager\n        })\n      )\n    );\n  }\n\n  private restore(key: string, manager: PersistManager<T>, arrControlFactory: ControlFactoryMap<T>): Observable<T> {\n    return wrapIntoObservable<T>(manager.getValue(key)).pipe(\n      take(1),\n      tap(value => {\n        if (!value) return;\n        handleFormArrays(this, value, arrControlFactory);\n        this.patchValue(value, { emitEvent: false });\n      })\n    );\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { FormBuilder as NgFormBuilder } from '@angular/forms';\nimport { FormArray } from './formArray';\nimport { FormControl } from './formControl';\nimport { FormGroup } from './formGroup';\nimport { AbstractControlOptions, AsyncValidatorFn, AbstractControl, OrBoxedValue, ValidatorFn } from './types';\n\nfunction isAbstractControlOptions<T>(\n  options: AbstractControlOptions<T> | { [key: string]: any }\n): options is AbstractControlOptions<T> {\n  return (\n    (<AbstractControlOptions<T>>options).asyncValidators !== undefined ||\n    (<AbstractControlOptions<T>>options).validators !== undefined ||\n    (<AbstractControlOptions<T>>options).updateOn !== undefined\n  );\n}\n\nexport type FbControlConfig<T = any> =\n  | AbstractControl<T>\n  | [OrBoxedValue<T>, ValidatorFn | ValidatorFn[] | null, AsyncValidatorFn | AsyncValidatorFn[] | null]\n  | [OrBoxedValue<T>, ValidatorFn | ValidatorFn[] | AbstractControlOptions | null]\n  | [T | OrBoxedValue<T>]\n  | OrBoxedValue<T>\n  | T;\n\nexport type FbGroupConfig<T = any> = { [key in keyof T]: FbControlConfig<T[key]> };\n\n@Injectable({ providedIn: 'root' })\nexport class FormBuilder extends NgFormBuilder {\n  group<T extends object, E extends object = any, GroupConfig extends FbGroupConfig<T> = FbGroupConfig<T>>(\n    controlsConfig: GroupConfig,\n    options?:\n      | AbstractControlOptions<T>\n      | {\n          validator?: ValidatorFn | ValidatorFn[];\n          asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[];\n        }\n      | null\n  ): FormGroup<T, E> {\n    const controls = (this as any)._reduceControls(controlsConfig);\n\n    let validators: ValidatorFn | ValidatorFn[] | null = null;\n    let asyncValidators: AsyncValidatorFn | AsyncValidatorFn[] | null = null;\n    let updateOn: AbstractControlOptions<T>['updateOn'] | undefined;\n\n    if (options != null) {\n      if (isAbstractControlOptions(options)) {\n        validators = options.validators != null ? options.validators : null;\n        asyncValidators = options.asyncValidators != null ? options.asyncValidators : null;\n        updateOn = options.updateOn != null ? options.updateOn : undefined;\n      } else {\n        // `options` are legacy form group options\n        validators = options['validator'] != null ? options['validator'] : null;\n        asyncValidators = options['asyncValidator'] != null ? options['asyncValidator'] : null;\n      }\n    }\n\n    // Todo: dan remove the any\n    return new FormGroup(controls, { asyncValidators, updateOn, validators });\n  }\n\n  control<T, E extends object = any>(\n    formState: OrBoxedValue<T>,\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null,\n    asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null\n  ): FormControl<T, E> {\n    return new FormControl(formState, validatorOrOpts, asyncValidator);\n  }\n\n  array<T, E extends object = any>(\n    controlsConfig: FbControlConfig<T>[],\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null,\n    asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null\n  ): FormArray<T, E> {\n    const controls = controlsConfig.map(c => (this as any)._createControl(c));\n    return new FormArray(controls, validatorOrOpts, asyncValidator);\n  }\n}\n","import { ControlValueAccessor as NgControlValueAccessor } from '@angular/forms';\n\nexport abstract class ControlValueAccessor<T = any> implements NgControlValueAccessor {\n  abstract writeValue(value: T): void;\n\n  onChange? = (value: T | null) => {};\n  onTouched? = () => {};\n\n  registerOnChange(fn: (value: T | null) => void): void {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n}\n","import { PersistManager } from './persistManager';\n\nexport class SessionStorageManager<T> implements PersistManager<T> {\n  setValue(key: string, data: T): T {\n    sessionStorage.setItem(key, JSON.stringify(data));\n    return data;\n  }\n\n  getValue(key: string): T {\n    return JSON.parse(sessionStorage.getItem(key) || '{}');\n  }\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n\nexport {AsyncValidator as ɵb,ExtractAbstractControl as ɵd,OrBoxedValue as ɵc,ValidatorOrOpts as ɵa} from './lib/types';"],"names":["NgFormArray","NgFormControl","NgFormGroup","NgFormBuilder"],"mappings":"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"}